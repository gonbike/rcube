/*
	This class is autogenerated by BuildOpenCVProxy. 
*/
using System;
using System.Runtime.InteropServices;

namespace OpenCVProxy.Interop
{
    public static partial class Cv
    {
        const string CvDllName = "cv110.dll";

        public static void InitializeLibrary()
        {
			IntPtr ptr = LoadLibrary(CvDllName);
        }

        [DllImport("kernel32.dll")]
        private static extern IntPtr LoadLibrary(string name);

		public const int CV_BLUR_NO_SCALE = 0;
		public const int CV_BLUR = 1;
		public const int CV_GAUSSIAN = 2;
		public const int CV_MEDIAN = 3;
		public const int CV_BILATERAL = 4;
		public const int CV_INPAINT_NS = 0;
		public const int CV_INPAINT_TELEA = 1;
		public const int CV_MAX_SOBEL_KSIZE = 7;
		public const int CV_BGR2BGRA = 0;
		public const int CV_BGRA2BGR = 1;
		public const int CV_BGR2RGBA = 2;
		public const int CV_RGBA2BGR = 3;
		public const int CV_BGR2RGB = 4;
		public const int CV_BGRA2RGBA = 5;
		public const int CV_BGR2GRAY = 6;
		public const int CV_RGB2GRAY = 7;
		public const int CV_GRAY2BGR = 8;
		public const int CV_GRAY2BGRA = 9;
		public const int CV_BGRA2GRAY = 10;
		public const int CV_RGBA2GRAY = 11;
		public const int CV_BGR2BGR565 = 12;
		public const int CV_RGB2BGR565 = 13;
		public const int CV_BGR5652BGR = 14;
		public const int CV_BGR5652RGB = 15;
		public const int CV_BGRA2BGR565 = 16;
		public const int CV_RGBA2BGR565 = 17;
		public const int CV_BGR5652BGRA = 18;
		public const int CV_BGR5652RGBA = 19;
		public const int CV_GRAY2BGR565 = 20;
		public const int CV_BGR5652GRAY = 21;
		public const int CV_BGR2BGR555 = 22;
		public const int CV_RGB2BGR555 = 23;
		public const int CV_BGR5552BGR = 24;
		public const int CV_BGR5552RGB = 25;
		public const int CV_BGRA2BGR555 = 26;
		public const int CV_RGBA2BGR555 = 27;
		public const int CV_BGR5552BGRA = 28;
		public const int CV_BGR5552RGBA = 29;
		public const int CV_GRAY2BGR555 = 30;
		public const int CV_BGR5552GRAY = 31;
		public const int CV_BGR2XYZ = 32;
		public const int CV_RGB2XYZ = 33;
		public const int CV_XYZ2BGR = 34;
		public const int CV_XYZ2RGB = 35;
		public const int CV_BGR2YCrCb = 36;
		public const int CV_RGB2YCrCb = 37;
		public const int CV_YCrCb2BGR = 38;
		public const int CV_YCrCb2RGB = 39;
		public const int CV_BGR2HSV = 40;
		public const int CV_RGB2HSV = 41;
		public const int CV_BGR2Lab = 44;
		public const int CV_RGB2Lab = 45;
		public const int CV_BayerBG2BGR = 46;
		public const int CV_BayerGB2BGR = 47;
		public const int CV_BayerRG2BGR = 48;
		public const int CV_BayerGR2BGR = 49;
		public const int CV_BGR2Luv = 50;
		public const int CV_RGB2Luv = 51;
		public const int CV_BGR2HLS = 52;
		public const int CV_RGB2HLS = 53;
		public const int CV_HSV2BGR = 54;
		public const int CV_HSV2RGB = 55;
		public const int CV_Lab2BGR = 56;
		public const int CV_Lab2RGB = 57;
		public const int CV_Luv2BGR = 58;
		public const int CV_Luv2RGB = 59;
		public const int CV_HLS2BGR = 60;
		public const int CV_HLS2RGB = 61;
		public const int CV_COLORCVT_MAX = 100;
		public const int CV_INTER_NN = 0;
		public const int CV_INTER_LINEAR = 1;
		public const int CV_INTER_CUBIC = 2;
		public const int CV_INTER_AREA = 3;
		public const int CV_WARP_FILL_OUTLIERS = 8;
		public const int CV_WARP_INVERSE_MAP = 16;
		public const int CV_SHAPE_RECT = 0;
		public const int CV_SHAPE_CROSS = 1;
		public const int CV_SHAPE_ELLIPSE = 2;
		public const int CV_SHAPE_CUSTOM = 100;
		public const int CV_MOP_OPEN = 2;
		public const int CV_MOP_CLOSE = 3;
		public const int CV_MOP_GRADIENT = 4;
		public const int CV_MOP_TOPHAT = 5;
		public const int CV_MOP_BLACKHAT = 6;
		public const int CV_TM_SQDIFF = 0;
		public const int CV_TM_SQDIFF_NORMED = 1;
		public const int CV_TM_CCORR = 2;
		public const int CV_TM_CCORR_NORMED = 3;
		public const int CV_TM_CCOEFF = 4;
		public const int CV_TM_CCOEFF_NORMED = 5;
		public const int CV_LKFLOW_PYR_A_READY = 1;
		public const int CV_LKFLOW_PYR_B_READY = 2;
		public const int CV_LKFLOW_INITIAL_GUESSES = 4;
		public const int CV_LKFLOW_GET_MIN_EIGENVALS = 8;
		public const int CV_POLY_APPROX_DP = 0;
		public const int CV_DOMINANT_IPAN = 1;
		public const int CV_CONTOURS_MATCH_I1 = 1;
		public const int CV_CONTOURS_MATCH_I2 = 2;
		public const int CV_CONTOURS_MATCH_I3 = 3;
		public const int CV_CONTOUR_TREES_MATCH_I1 = 1;
		public const int CV_CLOCKWISE = 1;
		public const int CV_COUNTER_CLOCKWISE = 2;
		public const int CV_COMP_CORREL = 0;
		public const int CV_COMP_CHISQR = 1;
		public const int CV_COMP_INTERSECT = 2;
		public const int CV_COMP_BHATTACHARYYA = 3;
		public const int CV_VALUE = 1;
		public const int CV_ARRAY = 2;
		public const int CV_DIST_MASK_3 = 3;
		public const int CV_DIST_MASK_5 = 5;
		public const int CV_DIST_MASK_PRECISE = 0;
		public const int CV_THRESH_MASK = 7;
		public const int CV_ADAPTIVE_THRESH_MEAN_C = 0;
		public const int CV_ADAPTIVE_THRESH_GAUSSIAN_C = 1;
		public const int CV_HOUGH_STANDARD = 0;
		public const int CV_HOUGH_PROBABILISTIC = 1;
		public const int CV_HOUGH_MULTI_SCALE = 2;
		public const int CV_HOUGH_GRADIENT = 3;
		public const int CV_HAAR_DO_CANNY_PRUNING = 1;
		public const int CV_HAAR_SCALE_IMAGE = 2;
		public const int CV_HAAR_FIND_BIGGEST_OBJECT = 4;
		public const int CV_HAAR_DO_ROUGH_SEARCH = 8;
		public const int CV_LMEDS = 4;
		public const int CV_RANSAC = 8;
		public const int CV_CALIB_CB_ADAPTIVE_THRESH = 1;
		public const int CV_CALIB_CB_NORMALIZE_IMAGE = 2;
		public const int CV_CALIB_CB_FILTER_QUADS = 4;
		public const int CV_CALIB_USE_INTRINSIC_GUESS = 1;
		public const int CV_CALIB_FIX_ASPECT_RATIO = 2;
		public const int CV_CALIB_FIX_PRINCIPAL_POINT = 4;
		public const int CV_CALIB_ZERO_TANGENT_DIST = 8;
		public const int CV_CALIB_FIX_FOCAL_LENGTH = 16;
		public const int CV_CALIB_FIX_K1 = 32;
		public const int CV_CALIB_FIX_K2 = 64;
		public const int CV_CALIB_FIX_K3 = 128;
		public const int CV_CALIB_FIX_INTRINSIC = 256;
		public const int CV_CALIB_SAME_FOCAL_LENGTH = 512;
		public const int CV_CALIB_ZERO_DISPARITY = 1024;
		public const int CV_FM_7POINT = 1;
		public const int CV_FM_8POINT = 2;
		public const int CV_STEREO_BM_NORMALIZED_RESPONSE = 0;
		public const int CV_STEREO_BM_BASIC = 0;
		public const int CV_STEREO_BM_FISH_EYE = 1;
		public const int CV_STEREO_BM_NARROW = 2;

		/// <summary>
		///  Copies source 2D array inside of the larger destination array and
		///    makes a border of the specified type (IPL_BORDER_*) around the copied area. 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCopyMakeBorder", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCopyMakeBorder(IntPtr src, IntPtr dst, CvPoint offset, int bordertype, CvScalar value);

		/// <summary>
		///  Smoothes array (removes noise) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSmooth", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSmooth(IntPtr src, IntPtr dst, int smoothtype, int size1, int size2, double sigma1, double sigma2);

		/// <summary>
		///  Convolves the image with the kernel 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFilter2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFilter2D(IntPtr src, IntPtr dst, IntPtr kernel, CvPoint anchor);

		/// <summary>
		///  Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvIntegral", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvIntegral(IntPtr image, IntPtr sum, IntPtr sqsum, IntPtr tilted_sum);

		/// <summary>
		/// 
		///    Smoothes the input image with gaussian kernel and then down-samples it.
		///    dst_width = floor(src_width/2)[+1],
		///    dst_height = floor(src_height/2)[+1]
		/// 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvPyrDown", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPyrDown(IntPtr src, IntPtr dst, int filter);

		/// <summary>
		///  
		///    Up-samples image and smoothes the result with gaussian kernel.
		///    dst_width = src_width*2,
		///    dst_height = src_height*2
		/// 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvPyrUp", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPyrUp(IntPtr src, IntPtr dst, int filter);

		/// <summary>
		///  Splits color or grayscale image into multiple connected components
		///    of nearly the same color/brightness using modification of Burt algorithm.
		///    comp with contain a pointer to sequence (CvSeq)
		///    of connected components (CvConnectedComp) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvPyrSegmentation", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPyrSegmentation(IntPtr src, IntPtr dst, IntPtr storage, IntPtr comp, int level, double threshold1, double threshold2);

		/// <summary>
		///  Filters image using meanshift algorithm 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvPyrMeanShiftFiltering", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPyrMeanShiftFiltering(IntPtr src, IntPtr dst, double sp, double sr, int max_level, CvTermCriteria termcrit);

		/// <summary>
		///  Segments image using seed "markers" 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvWatershed", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWatershed(IntPtr image, IntPtr markers);

		/// <summary>
		///  Inpaints the selected region in the image 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvInpaint", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInpaint(IntPtr src, IntPtr inpaint_mask, IntPtr dst, double inpaintRange, int flags);

		/// <summary>
		///  Calculates an image derivative using generalized Sobel
		///    (aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator.
		///    Scharr can be used only for the first dx or dy derivative 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSobel", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSobel(IntPtr src, IntPtr dst, int xorder, int yorder, int aperture_size);

		/// <summary>
		///  Calculates the image Laplacian: (d2/dx + d2/dy)I 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvLaplace", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvLaplace(IntPtr src, IntPtr dst, int aperture_size);

		/// <summary>
		///  Converts input array pixels from one color space to another 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCvtColor", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCvtColor(IntPtr src, IntPtr dst, int code);

		/// <summary>
		///  Resizes image (input array is resized to fit the destination array) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvResize", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvResize(IntPtr src, IntPtr dst, int interpolation);

		/// <summary>
		///  Warps image with affine transform  
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvWarpAffine", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWarpAffine(IntPtr src, IntPtr dst, IntPtr map_matrix, int flags, CvScalar fillval);

		/// <summary>
		///  Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGetAffineTransform", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetAffineTransform(IntPtr src, IntPtr dst, IntPtr map_matrix);

		/// <summary>
		///  Computes rotation_matrix matrix 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cv2DRotationMatrix", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cv2DRotationMatrix(CvPoint2D32f center, double angle, double scale, IntPtr map_matrix);

		/// <summary>
		///  Warps image with perspective (projective) transform 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvWarpPerspective", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWarpPerspective(IntPtr src, IntPtr dst, IntPtr map_matrix, int flags, CvScalar fillval);

		/// <summary>
		///  Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGetPerspectiveTransform", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetPerspectiveTransform(IntPtr src, IntPtr dst, IntPtr map_matrix);

		/// <summary>
		///  Performs generic geometric transformation using the specified coordinate maps 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvRemap", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRemap(IntPtr src, IntPtr dst, IntPtr mapx, IntPtr mapy, int flags, CvScalar fillval);

		/// <summary>
		///  Converts mapx & mapy from floating-point to integer formats for cvRemap 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvConvertMaps", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvConvertMaps(IntPtr mapx, IntPtr mapy, IntPtr mapxy, IntPtr mapalpha);

		/// <summary>
		///  Performs forward or inverse log-polar image transform 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvLogPolar", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvLogPolar(IntPtr src, IntPtr dst, CvPoint2D32f center, double M, int flags);

		/// <summary>
		///  creates structuring element used for morphological operations 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCreateStructuringElementEx", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, IntPtr values);

		/// <summary>
		///  releases structuring element 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvReleaseStructuringElement", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseStructuringElement(IntPtr element);

		/// <summary>
		///  erodes input image (applies minimum filter) one or more times.
		///    If element pointer is NULL, 3x3 rectangular element is used 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvErode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvErode(IntPtr src, IntPtr dst, IntPtr element, int iterations);

		/// <summary>
		///  dilates input image (applies maximum filter) one or more times.
		///    If element pointer is NULL, 3x3 rectangular element is used 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvDilate", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvDilate(IntPtr src, IntPtr dst, IntPtr element, int iterations);

		/// <summary>
		///  Performs complex morphological transformation 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMorphologyEx", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMorphologyEx(IntPtr src, IntPtr dst, IntPtr temp, IntPtr element, int operation, int iterations);

		/// <summary>
		///  Calculates all spatial and central moments up to the 3rd order 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMoments", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMoments(IntPtr arr, IntPtr moments, int binary);

		/// <summary>
		///  Retrieve particular spatial, central or normalized central moments 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGetSpatialMoment", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetSpatialMoment(IntPtr moments, int x_order, int y_order);

		[DllImport(CvDllName, EntryPoint = "cvGetCentralMoment", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetCentralMoment(IntPtr moments, int x_order, int y_order);

		[DllImport(CvDllName, EntryPoint = "cvGetNormalizedCentralMoment", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetNormalizedCentralMoment(IntPtr moments, int x_order, int y_order);

		/// <summary>
		///  Calculates 7 Hu's invariants from precalculated spatial and central moments 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGetHuMoments", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGetHuMoments(IntPtr moments, IntPtr hu_moments);

		/// <summary>
		///  Fetches pixels that belong to the specified line segment and stores them to the buffer.
		///    Returns the number of retrieved points. 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSampleLine", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSampleLine(IntPtr image, CvPoint pt1, CvPoint pt2, IntPtr buffer, int connectivity);

		/// <summary>
		///  Retrieves the rectangular image region with specified center from the input array.
		///  dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2).
		///  Values of pixels with fractional coordinates are retrieved using bilinear interpolation
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGetRectSubPix", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGetRectSubPix(IntPtr src, IntPtr dst, CvPoint2D32f center);

		/// <summary>
		///  Retrieves quadrangle from the input array.
		///     matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]' + b)
		///                 ( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels
		///                                      with fractional coordinates)
		/// 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGetQuadrangleSubPix", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGetQuadrangleSubPix(IntPtr src, IntPtr dst, IntPtr map_matrix);

		/// <summary>
		///  Measures similarity between template and overlapped windows in the source image
		///    and fills the resultant image with the measurements 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMatchTemplate", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMatchTemplate(IntPtr image, IntPtr templ, IntPtr result, int method);

		/// <summary>
		///  Computes earth mover distance between
		///    two weighted point sets (called signatures) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcEMD2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern float cvCalcEMD2(IntPtr signature1, IntPtr signature2, int distance_type, IntPtr distance_func, IntPtr cost_matrix, IntPtr flow, IntPtr lower_bound, IntPtr userdata);

		/// <summary>
		///  Retrieves outer and optionally inner boundaries of white (non-zero) connected
		///    components in the black (zero) background 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindContours", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvFindContours(IntPtr image, IntPtr storage, IntPtr first_contour, int header_size, int mode, int method, CvPoint offset);

		/// <summary>
		///  Initalizes contour retrieving process.
		///    Calls cvStartFindContours.
		///    Calls cvFindNextContour until null pointer is returned
		///    or some other condition becomes true.
		///    Calls cvEndFindContours at the end. 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvStartFindContours", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvStartFindContours(IntPtr image, IntPtr storage, int header_size, int mode, int method, CvPoint offset);

		/// <summary>
		///  Retrieves next contour 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindNextContour", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvFindNextContour(IntPtr scanner);

		/// <summary>
		///  Substitutes the last retrieved contour with the new one
		///    (if the substitutor is null, the last retrieved contour is removed from the tree) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSubstituteContour", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSubstituteContour(IntPtr scanner, IntPtr new_contour);

		/// <summary>
		///  Releases contour scanner and returns pointer to the first outer contour 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvEndFindContours", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvEndFindContours(IntPtr scanner);

		/// <summary>
		///  Approximates a single Freeman chain or a tree of chains to polygonal curves 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvApproxChains", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvApproxChains(IntPtr src_seq, IntPtr storage, int method, double parameter, int minimal_perimeter, int recursive);

		/// <summary>
		///  Initalizes Freeman chain reader.
		///    The reader is used to iteratively get coordinates of all the chain points.
		///    If the Freeman codes should be read as is, a simple sequence reader should be used 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvStartReadChainPoints", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStartReadChainPoints(IntPtr chain, IntPtr reader);

		/// <summary>
		///  Retrieves the next chain point 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvReadChainPoint", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvPoint cvReadChainPoint(IntPtr reader);

		/// <summary>
		///  Calculates optical flow for 2 images using classical Lucas & Kanade algorithm 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcOpticalFlowLK", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcOpticalFlowLK(IntPtr prev, IntPtr curr, CvSize win_size, IntPtr velx, IntPtr vely);

		/// <summary>
		///  Calculates optical flow for 2 images using block matching algorithm 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcOpticalFlowBM", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcOpticalFlowBM(IntPtr prev, IntPtr curr, CvSize block_size, CvSize shift_size, CvSize max_range, int use_previous, IntPtr velx, IntPtr vely);

		/// <summary>
		///  Calculates Optical flow for 2 images using Horn & Schunck algorithm 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcOpticalFlowHS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcOpticalFlowHS(IntPtr prev, IntPtr curr, int use_previous, IntPtr velx, IntPtr vely, double lambda, CvTermCriteria criteria);

		/// <summary>
		///  It is Lucas & Kanade method, modified to use pyramids.
		///    Also it does several iterations to get optical flow for
		///    every point at every pyramid level.
		///    Calculates optical flow between two images for certain set of points (i.e.
		///    it is a "sparse" optical flow, which is opposite to the previous 3 methods) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcOpticalFlowPyrLK", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcOpticalFlowPyrLK(IntPtr prev, IntPtr curr, IntPtr prev_pyr, IntPtr curr_pyr, IntPtr prev_features, IntPtr curr_features, int count, CvSize win_size, int level, IntPtr status, IntPtr track_error, CvTermCriteria criteria, int flags);

		/// <summary>
		///  Modification of a previous sparse optical flow algorithm to calculate
		///    affine flow 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcAffineFlowPyrLK", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcAffineFlowPyrLK(IntPtr prev, IntPtr curr, IntPtr prev_pyr, IntPtr curr_pyr, IntPtr prev_features, IntPtr curr_features, IntPtr matrices, int count, CvSize win_size, int level, IntPtr status, IntPtr track_error, CvTermCriteria criteria, int flags);

		/// <summary>
		///  Estimate rigid transformation between 2 images or 2 point sets 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvEstimateRigidTransform", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvEstimateRigidTransform(IntPtr A, IntPtr B, IntPtr M, int full_affine);

		/// <summary>
		///  Updates motion history image given motion silhouette 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvUpdateMotionHistory", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvUpdateMotionHistory(IntPtr silhouette, IntPtr mhi, double timestamp, double duration);

		/// <summary>
		///  Calculates gradient of the motion history image and fills
		///    a mask indicating where the gradient is valid 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcMotionGradient", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcMotionGradient(IntPtr mhi, IntPtr mask, IntPtr orientation, double delta1, double delta2, int aperture_size);

		/// <summary>
		///  Calculates average motion direction within a selected motion region 
		///    (region can be selected by setting ROIs and/or by composing a valid gradient mask
		///    with the region mask) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcGlobalOrientation", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvCalcGlobalOrientation(IntPtr orientation, IntPtr mask, IntPtr mhi, double timestamp, double duration);

		/// <summary>
		///  Splits a motion history image into a few parts corresponding to separate independent motions
		///    (e.g. left hand, right hand) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSegmentMotion", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvSegmentMotion(IntPtr mhi, IntPtr seg_mask, IntPtr storage, double timestamp, double seg_thresh);

		/// <summary>
		///  Adds image to accumulator 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvAcc", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAcc(IntPtr image, IntPtr sum, IntPtr mask);

		/// <summary>
		///  Adds squared image to accumulator 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSquareAcc", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSquareAcc(IntPtr image, IntPtr sqsum, IntPtr mask);

		/// <summary>
		///  Adds a product of two images to accumulator 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMultiplyAcc", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMultiplyAcc(IntPtr image1, IntPtr image2, IntPtr acc, IntPtr mask);

		/// <summary>
		///  Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvRunningAvg", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRunningAvg(IntPtr image, IntPtr acc, double alpha, IntPtr mask);

		/// <summary>
		///  Implements CAMSHIFT algorithm - determines object position, size and orientation
		///    from the object histogram back project (extension of meanshift) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCamShift", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvCamShift(IntPtr prob_image, CvRect window, CvTermCriteria criteria, IntPtr comp, IntPtr box);

		/// <summary>
		///  Implements MeanShift algorithm - determines object position
		///    from the object histogram back project 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMeanShift", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvMeanShift(IntPtr prob_image, CvRect window, CvTermCriteria criteria, IntPtr comp);

		/// <summary>
		///  Creates ConDensation filter state 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCreateConDensation", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateConDensation(int dynam_params, int measure_params, int sample_count);

		/// <summary>
		///  Releases ConDensation filter state 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvReleaseConDensation", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseConDensation(IntPtr condens);

		/// <summary>
		///  Updates ConDensation filter by time (predict future state of the system) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvConDensUpdateByTime", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvConDensUpdateByTime(IntPtr condens);

		/// <summary>
		///  Initializes ConDensation filter samples  
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvConDensInitSampleSet", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvConDensInitSampleSet(IntPtr condens, IntPtr lower_bound, IntPtr upper_bound);

		/// <summary>
		///  Creates Kalman filter and sets A, B, Q, R and state to some initial values 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCreateKalman", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateKalman(int dynam_params, int measure_params, int control_params);

		/// <summary>
		///  Releases Kalman filter state 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvReleaseKalman", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseKalman(IntPtr kalman);

		/// <summary>
		///  Updates Kalman filter by time (predicts future state of the system) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvKalmanPredict", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvKalmanPredict(IntPtr kalman, IntPtr control);

		/// <summary>
		///  Updates Kalman filter by measurement
		///    (corrects state of the system and internal matrices) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvKalmanCorrect", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvKalmanCorrect(IntPtr kalman, IntPtr measurement);

		/// <summary>
		///  Initializes Delaunay triangulation 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvInitSubdivDelaunay2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInitSubdivDelaunay2D(IntPtr subdiv, CvRect rect);

		/// <summary>
		///  Creates new subdivision 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCreateSubdiv2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateSubdiv2D(int subdiv_type, int header_size, int vtx_size, int quadedge_size, IntPtr storage);

		/// <summary>
		///  Inserts new point to the Delaunay triangulation 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSubdivDelaunay2DInsert", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvSubdivDelaunay2DInsert(IntPtr subdiv, CvPoint2D32f pt);

		/// <summary>
		///  Calculates Voronoi tesselation (i.e. coordinates of Voronoi points) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcSubdivVoronoi2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcSubdivVoronoi2D(IntPtr subdiv);

		/// <summary>
		///  Removes all Voronoi points from the tesselation 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvClearSubdivVoronoi2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvClearSubdivVoronoi2D(IntPtr subdiv);

		/// <summary>
		///  Finds the nearest to the given point vertex in subdivision. 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindNearestPoint2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvFindNearestPoint2D(IntPtr subdiv, CvPoint2D32f pt);

		/// <summary>
		///  Approximates a single polygonal curve (contour) or
		///    a tree of polygonal curves (contours) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvApproxPoly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvApproxPoly(IntPtr src_seq, int header_size, IntPtr storage, int method, double parameter, int parameter2);

		/// <summary>
		///  Finds high-curvature points of the contour 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindDominantPoints", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvFindDominantPoints(IntPtr contour, IntPtr storage, int method, double parameter1, double parameter2, double parameter3, double parameter4);

		/// <summary>
		///  Calculates perimeter of a contour or length of a part of contour 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvArcLength", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvArcLength(IntPtr curve, CvSlice slice, int is_closed);

		/// <summary>
		///  Calculates contour boundning rectangle (update=1) or
		///    just retrieves pre-calculated rectangle (update=0) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvBoundingRect", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvRect cvBoundingRect(IntPtr points, int update);

		/// <summary>
		///  Calculates area of a contour or contour segment 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvContourArea", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvContourArea(IntPtr contour, CvSlice slice);

		/// <summary>
		///  Finds minimum area rotated rectangle bounding a set of points 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMinAreaRect2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvBox2D cvMinAreaRect2(IntPtr points, IntPtr storage);

		/// <summary>
		///  Finds minimum enclosing circle for a set of points 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMinEnclosingCircle", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvMinEnclosingCircle(IntPtr points, IntPtr center, IntPtr radius);

		/// <summary>
		///  Compares two contours by matching their moments 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMatchShapes", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvMatchShapes(IntPtr object1, IntPtr object2, int method, double parameter);

		/// <summary>
		///  Builds hierarhical representation of a contour 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCreateContourTree", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateContourTree(IntPtr contour, IntPtr storage, double threshold);

		/// <summary>
		///  Reconstruct (completelly or partially) contour a from contour tree 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvContourFromContourTree", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvContourFromContourTree(IntPtr tree, IntPtr storage, CvTermCriteria criteria);

		/// <summary>
		///  Compares two contour trees 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMatchContourTrees", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvMatchContourTrees(IntPtr tree1, IntPtr tree2, int method, double threshold);

		/// <summary>
		///  Calculates histogram of a contour 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcPGH", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcPGH(IntPtr contour, IntPtr hist);

		/// <summary>
		///  Calculates exact convex hull of 2d point set 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvConvexHull2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvConvexHull2(IntPtr input, IntPtr hull_storage, int orientation, int return_points);

		/// <summary>
		///  Checks whether the contour is convex or not (returns 1 if convex, 0 if not) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCheckContourConvexity", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvCheckContourConvexity(IntPtr contour);

		/// <summary>
		///  Finds convexity defects for the contour 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvConvexityDefects", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvConvexityDefects(IntPtr contour, IntPtr convexhull, IntPtr storage);

		/// <summary>
		///  Fits ellipse into a set of 2d points 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFitEllipse2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvBox2D cvFitEllipse2(IntPtr points);

		/// <summary>
		///  Finds minimum rectangle containing two given rectangles 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMaxRect", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvRect cvMaxRect(IntPtr rect1, IntPtr rect2);

		/// <summary>
		///  Finds coordinates of the box vertices 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvBoxPoints", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvBoxPoints(CvBox2D box, IntPtr pt);

		/// <summary>
		///  Initializes sequence header for a matrix (column or row vector) of points -
		///    a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvPointSeqFromMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvPointSeqFromMat(int seq_kind, IntPtr mat, IntPtr contour_header, IntPtr block);

		/// <summary>
		///  Checks whether the point is inside polygon, outside, on an edge (at a vertex).
		///    Returns positive, negative or zero value, correspondingly.
		///    Optionally, measures a signed distance between
		///    the point and the nearest polygon edge (measure_dist=1) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvPointPolygonTest", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvPointPolygonTest(IntPtr contour, CvPoint2D32f pt, int measure_dist);

		/// <summary>
		///  Creates new histogram 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCreateHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateHist(int dims, IntPtr sizes, int type, IntPtr ranges, int uniform);

		/// <summary>
		///  Assignes histogram bin ranges 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSetHistBinRanges", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetHistBinRanges(IntPtr hist, IntPtr ranges, int uniform);

		/// <summary>
		///  Creates histogram header for array 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvMakeHistHeaderForArray", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvMakeHistHeaderForArray(int dims, IntPtr sizes, IntPtr hist, IntPtr data, IntPtr ranges, int uniform);

		/// <summary>
		///  Releases histogram 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvReleaseHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseHist(IntPtr hist);

		/// <summary>
		///  Clears all the histogram bins 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvClearHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvClearHist(IntPtr hist);

		/// <summary>
		///  Finds indices and values of minimum and maximum histogram bins 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGetMinMaxHistValue", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGetMinMaxHistValue(IntPtr hist, IntPtr min_value, IntPtr max_value, IntPtr min_idx, IntPtr max_idx);

		/// <summary>
		///  Normalizes histogram by dividing all bins by sum of the bins, multiplied by <factor>.
		///    After that sum of histogram bins is equal to <factor> 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvNormalizeHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvNormalizeHist(IntPtr hist, double factor);

		/// <summary>
		///  Clear all histogram bins that are below the threshold 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvThreshHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvThreshHist(IntPtr hist, double threshold);

		/// <summary>
		///  Compares two histogram 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCompareHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvCompareHist(IntPtr hist1, IntPtr hist2, int method);

		/// <summary>
		///  Copies one histogram to another. Destination histogram is created if
		///    the destination pointer is NULL 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCopyHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCopyHist(IntPtr src, IntPtr dst);

		/// <summary>
		///  Calculates bayesian probabilistic histograms
		///    (each or src and dst is an array of <number> histograms 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcBayesianProb", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcBayesianProb(IntPtr src, int number, IntPtr dst);

		/// <summary>
		///  Calculates array histogram 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcArrHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcArrHist(IntPtr arr, IntPtr hist, int accumulate, IntPtr mask);

		/// <summary>
		///  Calculates back project 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcArrBackProject", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcArrBackProject(IntPtr image, IntPtr dst, IntPtr hist);

		/// <summary>
		///  Does some sort of template matching but compares histograms of
		///    template and each window location 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcArrBackProjectPatch", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcArrBackProjectPatch(IntPtr image, IntPtr dst, CvSize range, IntPtr hist, int method, double factor);

		/// <summary>
		///  calculates probabilistic density (divides one histogram by another) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcProbDensity", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcProbDensity(IntPtr hist1, IntPtr hist2, IntPtr dst_hist, double scale);

		/// <summary>
		///  equalizes histogram of 8-bit single-channel image 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvEqualizeHist", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvEqualizeHist(IntPtr src, IntPtr dst);

		/// <summary>
		///  Updates active contour in order to minimize its cummulative
		///    (internal and external) energy. 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSnakeImage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSnakeImage(IntPtr image, IntPtr points, int length, IntPtr alpha, IntPtr beta, IntPtr gamma, int coeff_usage, CvSize win, CvTermCriteria criteria, int calc_gradient);

		/// <summary>
		///  Calculates the cooficients of the homography matrix 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcImageHomography", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcImageHomography(IntPtr line, IntPtr center, IntPtr intrinsic, IntPtr homography);

		/// <summary>
		///  Applies distance transform to binary image 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvDistTransform", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvDistTransform(IntPtr src, IntPtr dst, int distance_type, int mask_size, IntPtr mask, IntPtr labels);

		/// <summary>
		///  Applies fixed-level threshold to grayscale image.
		///    This is a basic operation applied before retrieving contours 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvThreshold", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvThreshold(IntPtr src, IntPtr dst, double threshold, double max_value, int threshold_type);

		/// <summary>
		///  Applies adaptive threshold to grayscale image.
		///    The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and
		///    CV_ADAPTIVE_THRESH_GAUSSIAN_C are:
		///    neighborhood size (3, 5, 7 etc.),
		///    and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvAdaptiveThreshold", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAdaptiveThreshold(IntPtr src, IntPtr dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1);

		/// <summary>
		///  Fills the connected component until the color difference gets large enough 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFloodFill", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFloodFill(IntPtr image, CvPoint seed_point, CvScalar new_val, CvScalar lo_diff, CvScalar up_diff, IntPtr comp, int flags, IntPtr mask);

		/// <summary>
		///  Runs canny edge detector 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCanny", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCanny(IntPtr image, IntPtr edges, double threshold1, double threshold2, int aperture_size);

		/// <summary>
		///  Calculates constraint image for corner detection
		///    Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy.
		///    Applying threshold to the result gives coordinates of corners 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvPreCornerDetect", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPreCornerDetect(IntPtr image, IntPtr corners, int aperture_size);

		/// <summary>
		///  Calculates eigen values and vectors of 2x2
		///    gradient covariation matrix at every image pixel 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCornerEigenValsAndVecs", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCornerEigenValsAndVecs(IntPtr image, IntPtr eigenvv, int block_size, int aperture_size);

		/// <summary>
		///  Calculates minimal eigenvalue for 2x2 gradient covariation matrix at
		///    every image pixel 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCornerMinEigenVal", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCornerMinEigenVal(IntPtr image, IntPtr eigenval, int block_size, int aperture_size);

		/// <summary>
		///  Harris corner detector:
		///    Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCornerHarris", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCornerHarris(IntPtr image, IntPtr harris_responce, int block_size, int aperture_size, double k);

		/// <summary>
		///  Adjust corner position using some sort of gradient search 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindCornerSubPix", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFindCornerSubPix(IntPtr image, IntPtr corners, int count, CvSize win, CvSize zero_zone, CvTermCriteria criteria);

		/// <summary>
		///  Finds a sparse set of points within the selected region
		///    that seem to be easy to track 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvGoodFeaturesToTrack", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGoodFeaturesToTrack(IntPtr image, IntPtr eig_image, IntPtr temp_image, IntPtr corners, IntPtr corner_count, double quality_level, double min_distance, IntPtr mask, int block_size, int use_harris, double k);

		/// <summary>
		///  Finds lines on binary image using one of several methods.
		///    line_storage is either memory storage or 1 x <max number of lines> CvMat, its
		///    number of columns is changed by the function.
		///    method is one of CV_HOUGH_*;
		///    rho, theta and threshold are used for each of those methods;
		///    param1 ~ line length, param2 ~ line gap - for probabilistic,
		///    param1 ~ srn, param2 ~ stn - for multi-scale 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvHoughLines2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvHoughLines2(IntPtr image, IntPtr line_storage, int method, double rho, double theta, int threshold, double param1, double param2);

		/// <summary>
		///  Finds circles in the image 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvHoughCircles", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvHoughCircles(IntPtr image, IntPtr circle_storage, int method, double dp, double min_dist, double param1, double param2, int min_radius, int max_radius);

		/// <summary>
		///  Fits a line into set of 2d or 3d points in a robust way (M-estimator technique) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFitLine", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFitLine(IntPtr points, int dist_type, double param, double reps, double aeps, IntPtr line);

		/// <summary>
		///  Loads haar classifier cascade from a directory.
		///    It is obsolete: convert your cascade to xml and use cvLoad instead 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvLoadHaarClassifierCascade", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvLoadHaarClassifierCascade([MarshalAs(UnmanagedType.LPStr)] string directory, CvSize orig_window_size);

		[DllImport(CvDllName, EntryPoint = "cvReleaseHaarClassifierCascade", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseHaarClassifierCascade(IntPtr cascade);

		[DllImport(CvDllName, EntryPoint = "cvHaarDetectObjects", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvHaarDetectObjects(IntPtr image, IntPtr cascade, IntPtr storage, double scale_factor, int min_neighbors, int flags, CvSize min_size);

		/// <summary>
		///  sets images for haar classifier cascade 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvSetImagesForHaarClassifierCascade", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetImagesForHaarClassifierCascade(IntPtr cascade, IntPtr sum, IntPtr sqsum, IntPtr tilted_sum, double scale);

		/// <summary>
		///  runs the cascade on the specified window 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvRunHaarClassifierCascade", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvRunHaarClassifierCascade(IntPtr cascade, CvPoint pt, int start_stage);

		/// <summary>
		///  Transforms the input image to compensate lens distortion 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvUndistort2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvUndistort2(IntPtr src, IntPtr dst, IntPtr camera_matrix, IntPtr distortion_coeffs);

		/// <summary>
		///  Computes transformation map from intrinsic camera parameters
		///    that can used by cvRemap 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvInitUndistortMap", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInitUndistortMap(IntPtr camera_matrix, IntPtr distortion_coeffs, IntPtr mapx, IntPtr mapy);

		/// <summary>
		///  Computes undistortion+rectification map for a head of stereo camera 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvInitUndistortRectifyMap", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInitUndistortRectifyMap(IntPtr camera_matrix, IntPtr dist_coeffs, IntPtr R, IntPtr new_camera_matrix, IntPtr mapx, IntPtr mapy);

		/// <summary>
		///  Computes the original (undistorted) feature coordinates
		///    from the observed (distorted) coordinates 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvUndistortPoints", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvUndistortPoints(IntPtr src, IntPtr dst, IntPtr camera_matrix, IntPtr dist_coeffs, IntPtr R, IntPtr P);

		/// <summary>
		///  Converts rotation vector to rotation matrix or vice versa 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvRodrigues2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvRodrigues2(IntPtr src, IntPtr dst, IntPtr jacobian);

		/// <summary>
		///  Finds perspective transformation between the object plane and image (view) plane 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindHomography", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvFindHomography(IntPtr src_points, IntPtr dst_points, IntPtr homography, int method, double ransacReprojThreshold, IntPtr mask);

		/// <summary>
		///  Computes d(AB)/dA and d(AB)/dB 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalcMatMulDeriv", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcMatMulDeriv(IntPtr A, IntPtr B, IntPtr dABdA, IntPtr dABdB);

		/// <summary>
		///  Computes r3 = rodrigues(rodrigues(r2)*rodrigues(r1)),
		///    t3 = rodrigues(r2)*t1 + t2 and the respective derivatives 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvComposeRT", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvComposeRT(IntPtr _rvec1, IntPtr _tvec1, IntPtr _rvec2, IntPtr _tvec2, IntPtr _rvec3, IntPtr _tvec3, IntPtr dr3dr1, IntPtr dr3dt1, IntPtr dr3dr2, IntPtr dr3dt2, IntPtr dt3dr1, IntPtr dt3dt1, IntPtr dt3dr2, IntPtr dt3dt2);

		/// <summary>
		///  Projects object points to the view plane using
		///    the specified extrinsic and intrinsic camera parameters 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvProjectPoints2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvProjectPoints2(IntPtr object_points, IntPtr rotation_vector, IntPtr translation_vector, IntPtr camera_matrix, IntPtr distortion_coeffs, IntPtr image_points, IntPtr dpdrot, IntPtr dpdt, IntPtr dpdf, IntPtr dpdc, IntPtr dpddist, double aspect_ratio);

		/// <summary>
		///  Finds extrinsic camera parameters from
		///    a few known corresponding point pairs and intrinsic parameters 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindExtrinsicCameraParams2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFindExtrinsicCameraParams2(IntPtr object_points, IntPtr image_points, IntPtr camera_matrix, IntPtr distortion_coeffs, IntPtr rotation_vector, IntPtr translation_vector);

		/// <summary>
		///  Computes initial estimate of the intrinsic camera parameters
		///    in case of planar calibration target (e.g. chessboard) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvInitIntrinsicParams2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInitIntrinsicParams2D(IntPtr object_points, IntPtr image_points, IntPtr npoints, CvSize image_size, IntPtr camera_matrix, double aspect_ratio);

		/// <summary>
		///  Detects corners on a chessboard calibration pattern 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindChessboardCorners", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvFindChessboardCorners(IntPtr image, CvSize pattern_size, IntPtr corners, IntPtr corner_count, int flags);

		/// <summary>
		///  Draws individual chessboard corners or the whole chessboard detected 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvDrawChessboardCorners", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvDrawChessboardCorners(IntPtr image, CvSize pattern_size, IntPtr corners, int count, int pattern_was_found);

		/// <summary>
		///  Finds intrinsic and extrinsic camera parameters
		///    from a few views of known calibration pattern 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCalibrateCamera2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalibrateCamera2(IntPtr object_points, IntPtr image_points, IntPtr point_counts, CvSize image_size, IntPtr camera_matrix, IntPtr distortion_coeffs, IntPtr rotation_vectors, IntPtr translation_vectors, int flags);

		/// <summary>
		///  Computes the transformation from one camera coordinate system to another one
		///    from a few correspondent views of the same calibration target. Optionally, calibrates
		///    both cameras 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvStereoCalibrate", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStereoCalibrate(IntPtr object_points, IntPtr image_points1, IntPtr image_points2, IntPtr npoints, IntPtr camera_matrix1, IntPtr dist_coeffs1, IntPtr camera_matrix2, IntPtr dist_coeffs2, CvSize image_size, IntPtr R, IntPtr T, IntPtr E, IntPtr F, CvTermCriteria term_crit, int flags);

		/// <summary>
		///  Computes 3D rotations (+ optional shift) for each camera coordinate system to make both
		///    views parallel (=> to make all the epipolar lines horizontal or vertical) 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvStereoRectify", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStereoRectify(IntPtr camera_matrix1, IntPtr camera_matrix2, IntPtr dist_coeffs1, IntPtr dist_coeffs2, CvSize image_size, IntPtr R, IntPtr T, IntPtr R1, IntPtr R2, IntPtr P1, IntPtr P2, IntPtr Q, int flags);

		/// <summary>
		///  Computes rectification transformations for uncalibrated pair of images using a set
		///    of point correspondences 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvStereoRectifyUncalibrated", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvStereoRectifyUncalibrated(IntPtr points1, IntPtr points2, IntPtr F, CvSize img_size, IntPtr H1, IntPtr H2, double threshold);

		/// <summary>
		///  Allocates and initializes CvPOSITObject structure before doing cvPOSIT 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvCreatePOSITObject", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreatePOSITObject(IntPtr points, int point_count);

		/// <summary>
		///  Releases CvPOSITObject structure 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvReleasePOSITObject", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleasePOSITObject(IntPtr posit_object);

		/// <summary>
		///  updates the number of RANSAC iterations 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvRANSACUpdateNumIters", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvRANSACUpdateNumIters(double p, double err_prob, int model_points, int max_iters);

		[DllImport(CvDllName, EntryPoint = "cvConvertPointsHomogeneous", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvConvertPointsHomogeneous(IntPtr src, IntPtr dst);

		/// <summary>
		///  Calculates fundamental matrix given a set of corresponding points 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvFindFundamentalMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvFindFundamentalMat(IntPtr points1, IntPtr points2, IntPtr fundamental_matrix, int method, double param1, double param2, IntPtr status);

		/// <summary>
		///  For each input point on one of images
		///    computes parameters of the corresponding
		///    epipolar line on the other image 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvComputeCorrespondEpilines", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvComputeCorrespondEpilines(IntPtr points, int which_image, IntPtr fundamental_matrix, IntPtr correspondent_lines);

		/// <summary>
		///  Reprojects the computed disparity image to the 3D space using the specified 4x4 matrix 
		/// </summary>
		[DllImport(CvDllName, EntryPoint = "cvReprojectImageTo3D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReprojectImageTo3D(IntPtr disparityImage, IntPtr _3dImage, IntPtr Q);
	}
}
