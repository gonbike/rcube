/*
	This class is autogenerated by BuildOpenCVProxy. 
*/
using System;
using System.Runtime.InteropServices;

namespace OpenCVProxy.Interop
{
    public static partial class CxCore
    {
        const string CxCoreDllName = "cxcore110.dll";

        public static void InitializeLibrary()
        {
			IntPtr ptr = LoadLibrary(CxCoreDllName);
        }

        [DllImport("kernel32.dll")]
        private static extern IntPtr LoadLibrary(string name);

		public const int CV_MAX_ARR = 10;
		public const int CV_NO_DEPTH_CHECK = 1;
		public const int CV_NO_CN_CHECK = 2;
		public const int CV_NO_SIZE_CHECK = 4;
		public const int CV_CMP_EQ = 0;
		public const int CV_CMP_GT = 1;
		public const int CV_CMP_GE = 2;
		public const int CV_CMP_LT = 3;
		public const int CV_CMP_LE = 4;
		public const int CV_CMP_NE = 5;
		public const int CV_CHECK_RANGE = 1;
		public const int CV_CHECK_QUIET = 2;
		public const int CV_RAND_UNI = 0;
		public const int CV_RAND_NORMAL = 1;
		public const int CV_SORT_EVERY_ROW = 0;
		public const int CV_SORT_EVERY_COLUMN = 1;
		public const int CV_SORT_ASCENDING = 0;
		public const int CV_SORT_DESCENDING = 16;
		public const int CV_GEMM_A_T = 1;
		public const int CV_GEMM_B_T = 2;
		public const int CV_GEMM_C_T = 4;
		public const int CV_SVD_MODIFY_A = 1;
		public const int CV_SVD_U_T = 2;
		public const int CV_SVD_V_T = 4;
		public const int CV_LU = 0;
		public const int CV_SVD = 1;
		public const int CV_SVD_SYM = 2;
		public const int CV_LSQ = 8;
		public const int CV_COVAR_SCRAMBLED = 0;
		public const int CV_COVAR_NORMAL = 1;
		public const int CV_COVAR_USE_AVG = 2;
		public const int CV_COVAR_SCALE = 4;
		public const int CV_COVAR_ROWS = 8;
		public const int CV_COVAR_COLS = 16;
		public const int CV_PCA_DATA_AS_ROW = 0;
		public const int CV_PCA_DATA_AS_COL = 1;
		public const int CV_PCA_USE_AVG = 2;
		public const int CV_C = 1;
		public const int CV_L1 = 2;
		public const int CV_L2 = 4;
		public const int CV_NORM_MASK = 7;
		public const int CV_RELATIVE = 8;
		public const int CV_DIFF = 16;
		public const int CV_MINMAX = 32;
		public const int CV_REDUCE_SUM = 0;
		public const int CV_REDUCE_AVG = 1;
		public const int CV_REDUCE_MAX = 2;
		public const int CV_REDUCE_MIN = 3;
		public const int CV_DXT_FORWARD = 0;
		public const int CV_DXT_INVERSE = 1;
		public const int CV_FRONT = 1;
		public const int CV_BACK = 0;
		public const int CV_GRAPH_VERTEX = 1;
		public const int CV_GRAPH_TREE_EDGE = 2;
		public const int CV_GRAPH_BACK_EDGE = 4;
		public const int CV_GRAPH_FORWARD_EDGE = 8;
		public const int CV_GRAPH_CROSS_EDGE = 16;
		public const int CV_GRAPH_ANY_EDGE = 30;
		public const int CV_GRAPH_NEW_TREE = 32;
		public const int CV_GRAPH_BACKTRACKING = 64;
		public const int CV_AA = 16;
		public const int CV_FONT_HERSHEY_SIMPLEX = 0;
		public const int CV_FONT_HERSHEY_PLAIN = 1;
		public const int CV_FONT_HERSHEY_DUPLEX = 2;
		public const int CV_FONT_HERSHEY_COMPLEX = 3;
		public const int CV_FONT_HERSHEY_TRIPLEX = 4;
		public const int CV_FONT_HERSHEY_COMPLEX_SMALL = 5;
		public const int CV_FONT_HERSHEY_SCRIPT_SIMPLEX = 6;
		public const int CV_FONT_HERSHEY_SCRIPT_COMPLEX = 7;
		public const int CV_FONT_ITALIC = 16;

		/// <summary>
		///  <malloc> wrapper.
		///    If there is no enough memory, the function
		///    (as well as other OpenCV functions that call cvAlloc)
		///    raises an error. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAlloc", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvAlloc(int size);

		/// <summary>
		///  <free> wrapper.
		///    Here and further all the memory releasing functions
		///    (that all call cvFree) take double pointer in order to
		///    to clear pointer to the data after releasing it.
		///    Passing pointer to NULL pointer is Ok: nothing happens in this case
		/// 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvFree_", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFree_(IntPtr ptr);

		/// <summary>
		///  Allocates and initializes IplImage header 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateImageHeader", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateImageHeader(CvSize size, int depth, int channels);

		/// <summary>
		///  Inializes IplImage header 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitImageHeader", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvInitImageHeader(IntPtr image, CvSize size, int depth, int channels, int origin, int align);

		/// <summary>
		///  Creates IPL image (header and data) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateImage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateImage(CvSize size, int depth, int channels);

		/// <summary>
		///  Releases (i.e. deallocates) IPL image header 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseImageHeader", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseImageHeader(IntPtr image);

		/// <summary>
		///  Releases IPL image header and data 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseImage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseImage(IntPtr image);

		/// <summary>
		///  Creates a copy of IPL image (widthStep may differ) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCloneImage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCloneImage(IntPtr image);

		/// <summary>
		///  Sets a Channel Of Interest (only a few functions support COI) -
		///    use cvCopy to extract the selected channel and/or put it back 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetImageCOI", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetImageCOI(IntPtr image, int coi);

		/// <summary>
		///  Retrieves image Channel Of Interest 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetImageCOI", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetImageCOI(IntPtr image);

		/// <summary>
		///  Sets image ROI (region of interest) (COI is not changed) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetImageROI", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetImageROI(IntPtr image, CvRect rect);

		/// <summary>
		///  Resets image ROI and COI 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvResetImageROI", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvResetImageROI(IntPtr image);

		/// <summary>
		///  Retrieves image ROI 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetImageROI", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvRect cvGetImageROI(IntPtr image);

		/// <summary>
		///  Allocates and initalizes CvMat header 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateMatHeader", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateMatHeader(int rows, int cols, int type);

		/// <summary>
		///  Initializes CvMat header 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitMatHeader", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvInitMatHeader(IntPtr mat, int rows, int cols, int type, IntPtr data, int step);

		/// <summary>
		///  Allocates and initializes CvMat header and allocates data 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateMat(int rows, int cols, int type);

		/// <summary>
		///  Releases CvMat header and deallocates matrix data
		///    (reference counting is used for data) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseMat(IntPtr mat);

		/// <summary>
		///  Creates an exact copy of the input matrix (except, may be, step value) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCloneMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCloneMat(IntPtr mat);

		/// <summary>
		///  Makes a new matrix from <rect> subrectangle of input array.
		///    No data is copied 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetSubRect", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetSubRect(IntPtr arr, IntPtr submat, CvRect rect);

		/// <summary>
		///  Selects row span of the input array: arr(start_row:delta_row:end_row,:)
		///     (end_row is not included into the span). 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetRows", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetRows(IntPtr arr, IntPtr submat, int start_row, int end_row, int delta_row);

		/// <summary>
		///  Selects column span of the input array: arr(:,start_col:end_col)
		///    (end_col is not included into the span) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetCols", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetCols(IntPtr arr, IntPtr submat, int start_col, int end_col);

		/// <summary>
		///  Select a diagonal of the input array.
		///    (diag = 0 means the main diagonal, >0 means a diagonal above the main one,
		///    <0 - below the main one).
		///    The diagonal will be represented as a column (nx1 matrix). 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetDiag", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetDiag(IntPtr arr, IntPtr submat, int diag);

		/// <summary>
		///  low-level scalar <-> raw data conversion functions 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvScalarToRawData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvScalarToRawData(IntPtr scalar, IntPtr data, int type, int extend_to_12);

		[DllImport(CxCoreDllName, EntryPoint = "cvRawDataToScalar", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRawDataToScalar(IntPtr data, int type, IntPtr scalar);

		/// <summary>
		///  Allocates and initializes CvMatND header 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateMatNDHeader", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateMatNDHeader(int dims, IntPtr sizes, int type);

		/// <summary>
		///  Allocates and initializes CvMatND header and allocates data 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateMatND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateMatND(int dims, IntPtr sizes, int type);

		/// <summary>
		///  Initializes preallocated CvMatND header 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitMatNDHeader", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvInitMatNDHeader(IntPtr mat, int dims, IntPtr sizes, int type, IntPtr data);

		/// <summary>
		///  Creates a copy of CvMatND (except, may be, steps) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCloneMatND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCloneMatND(IntPtr mat);

		/// <summary>
		///  Allocates and initializes CvSparseMat header and allocates data 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateSparseMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateSparseMat(int dims, IntPtr sizes, int type);

		/// <summary>
		///  Releases CvSparseMat 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseSparseMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseSparseMat(IntPtr mat);

		/// <summary>
		///  Creates a copy of CvSparseMat (except, may be, zero items) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCloneSparseMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCloneSparseMat(IntPtr mat);

		/// <summary>
		///  Initializes sparse array iterator
		///    (returns the first node or NULL if the array is empty) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitSparseMatIterator", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvInitSparseMatIterator(IntPtr mat, IntPtr mat_iterator);

		/// <summary>
		///  initializes iterator that traverses through several arrays simulteneously
		///    (the function together with cvNextArraySlice is used for
		///     N-ari element-wise operations) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitNArrayIterator", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvInitNArrayIterator(int count, IntPtr arrs, IntPtr mask, IntPtr stubs, IntPtr array_iterator, int flags);

		/// <summary>
		///  returns zero value if iteration is finished, non-zero (slice length) otherwise 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvNextNArraySlice", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvNextNArraySlice(IntPtr array_iterator);

		/// <summary>
		///  Returns type of array elements:
		///    CV_8UC1 ... CV_64FC4 ... 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetElemType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetElemType(IntPtr arr);

		/// <summary>
		///  Retrieves number of an array dimensions and
		///    optionally sizes of the dimensions 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetDims", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetDims(IntPtr arr, IntPtr sizes);

		/// <summary>
		///  Retrieves size of a particular array dimension.
		///    For 2d arrays cvGetDimSize(arr,0) returns number of rows (image height)
		///    and cvGetDimSize(arr,1) returns number of columns (image width) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetDimSize", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetDimSize(IntPtr arr, int index);

		/// <summary>
		///  ptr = &arr(idx0,idx1,...). All indexes are zero-based,
		///    the major dimensions go first (e.g. (y,x) for 2D, (z,y,x) for 3D 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvPtr1D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvPtr1D(IntPtr arr, int idx0, IntPtr type);

		[DllImport(CxCoreDllName, EntryPoint = "cvPtr2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvPtr2D(IntPtr arr, int idx0, int idx1, IntPtr type);

		[DllImport(CxCoreDllName, EntryPoint = "cvPtr3D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvPtr3D(IntPtr arr, int idx0, int idx1, int idx2, IntPtr type);

		/// <summary>
		///  For CvMat or IplImage number of indices should be 2
		///    (row index (y) goes first, column index (x) goes next).
		///    For CvMatND or CvSparseMat number of infices should match number of <dims> and
		///    indices order should match the array dimension order. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvPtrND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvPtrND(IntPtr arr, IntPtr idx, IntPtr type, int create_node, IntPtr precalc_hashval);

		/// <summary>
		///  value = arr(idx0,idx1,...) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGet1D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvGet1D(IntPtr arr, int idx0);

		[DllImport(CxCoreDllName, EntryPoint = "cvGet2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvGet2D(IntPtr arr, int idx0, int idx1);

		[DllImport(CxCoreDllName, EntryPoint = "cvGet3D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvGet3D(IntPtr arr, int idx0, int idx1, int idx2);

		[DllImport(CxCoreDllName, EntryPoint = "cvGetND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvGetND(IntPtr arr, IntPtr idx);

		/// <summary>
		///  for 1-channel arrays 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetReal1D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetReal1D(IntPtr arr, int idx0);

		[DllImport(CxCoreDllName, EntryPoint = "cvGetReal2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetReal2D(IntPtr arr, int idx0, int idx1);

		[DllImport(CxCoreDllName, EntryPoint = "cvGetReal3D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetReal3D(IntPtr arr, int idx0, int idx1, int idx2);

		[DllImport(CxCoreDllName, EntryPoint = "cvGetRealND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetRealND(IntPtr arr, IntPtr idx);

		/// <summary>
		///  arr(idx0,idx1,...) = value 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSet1D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSet1D(IntPtr arr, int idx0, CvScalar value);

		[DllImport(CxCoreDllName, EntryPoint = "cvSet2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSet2D(IntPtr arr, int idx0, int idx1, CvScalar value);

		[DllImport(CxCoreDllName, EntryPoint = "cvSet3D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSet3D(IntPtr arr, int idx0, int idx1, int idx2, CvScalar value);

		[DllImport(CxCoreDllName, EntryPoint = "cvSetND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetND(IntPtr arr, IntPtr idx, CvScalar value);

		/// <summary>
		///  for 1-channel arrays 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetReal1D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetReal1D(IntPtr arr, int idx0, double value);

		[DllImport(CxCoreDllName, EntryPoint = "cvSetReal2D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetReal2D(IntPtr arr, int idx0, int idx1, double value);

		[DllImport(CxCoreDllName, EntryPoint = "cvSetReal3D", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetReal3D(IntPtr arr, int idx0, int idx1, int idx2, double value);

		[DllImport(CxCoreDllName, EntryPoint = "cvSetRealND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetRealND(IntPtr arr, IntPtr idx, double value);

		/// <summary>
		///  clears element of ND dense array,
		///    in case of sparse arrays it deletes the specified node 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvClearND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvClearND(IntPtr arr, IntPtr idx);

		/// <summary>
		///  Converts CvArr (IplImage or CvMat,...) to CvMat.
		///    If the last parameter is non-zero, function can
		///    convert multi(>2)-dimensional array to CvMat as long as
		///    the last array's dimension is continous. The resultant
		///    matrix will be have appropriate (a huge) number of rows 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetMat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetMat(IntPtr arr, IntPtr header, IntPtr coi, int allowND);

		/// <summary>
		///  Converts CvArr (IplImage or CvMat) to IplImage 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetImage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetImage(IntPtr arr, IntPtr image_header);

		/// <summary>
		///  Changes a shape of multi-dimensional array.
		///    new_cn == 0 means that number of channels remains unchanged.
		///    new_dims == 0 means that number and sizes of dimensions remain the same
		///    (unless they need to be changed to set the new number of channels)
		///    if new_dims == 1, there is no need to specify new dimension sizes
		///    The resultant configuration should be achievable w/o data copying.
		///    If the resultant array is sparse, CvSparseMat header should be passed
		///    to the function else if the result is 1 or 2 dimensional,
		///    CvMat header should be passed to the function
		///    else CvMatND header should be passed 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReshapeMatND", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvReshapeMatND(IntPtr arr, int sizeof_header, IntPtr header, int new_cn, int new_dims, IntPtr new_sizes);

		[DllImport(CxCoreDllName, EntryPoint = "cvReshape", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvReshape(IntPtr arr, IntPtr header, int new_cn, int new_rows);

		/// <summary>
		///  Repeats source 2d array several times in both horizontal and
		///    vertical direction to fill destination array 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRepeat", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRepeat(IntPtr src, IntPtr dst);

		/// <summary>
		///  Allocates array data 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCreateData(IntPtr arr);

		/// <summary>
		///  Releases array data 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseData(IntPtr arr);

		/// <summary>
		///  Attaches user data to the array header. The step is reffered to
		///    the pre-last dimension. That is, all the planes of the array
		///    must be joint (w/o gaps) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetData(IntPtr arr, IntPtr data, int step);

		/// <summary>
		///  Retrieves raw data of CvMat, IplImage or CvMatND.
		///    In the latter case the function raises an error if
		///    the array can not be represented as a matrix 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetRawData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGetRawData(IntPtr arr, IntPtr data, IntPtr step, IntPtr roi_size);

		/// <summary>
		///  Returns width and height of array in elements 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetSize", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvSize cvGetSize(IntPtr arr);

		/// <summary>
		///  Copies source array to destination array 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCopy", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCopy(IntPtr src, IntPtr dst, IntPtr mask);

		/// <summary>
		///  Sets all or "masked" elements of input array
		///    to the same value
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSet", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSet(IntPtr arr, CvScalar value, IntPtr mask);

		/// <summary>
		///  Clears all the array elements (sets them to 0) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetZero", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetZero(IntPtr arr);

		/// <summary>
		///  Splits a multi-channel array into the set of single-channel arrays or
		///    extracts particular [color] plane 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSplit", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSplit(IntPtr src, IntPtr dst0, IntPtr dst1, IntPtr dst2, IntPtr dst3);

		/// <summary>
		///  Merges a set of single-channel arrays into the single multi-channel array
		///    or inserts one particular [color] plane to the array 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMerge", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMerge(IntPtr src0, IntPtr src1, IntPtr src2, IntPtr src3, IntPtr dst);

		/// <summary>
		///  Copies several channels from input arrays to
		///    certain channels of output arrays 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMixChannels", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMixChannels(IntPtr src, int src_count, IntPtr dst, int dst_count, IntPtr from_to, int pair_count);

		/// <summary>
		///  Performs linear transformation on every source array element:
		///    dst(x,y,c) = scale*src(x,y,c)+shift.
		///    Arbitrary combination of input and output array depths are allowed
		///    (number of channels must be the same), thus the function can be used
		///    for type conversion 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvConvertScale", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvConvertScale(IntPtr src, IntPtr dst, double scale, double shift);

		/// <summary>
		///  Performs linear transformation on every source array element,
		///    stores absolute value of the result:
		///    dst(x,y,c) = abs(scale*src(x,y,c)+shift).
		///    destination array must have 8u type.
		///    In other cases one may use cvConvertScale + cvAbsDiffS 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvConvertScaleAbs", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvConvertScaleAbs(IntPtr src, IntPtr dst, double scale, double shift);

		/// <summary>
		///  checks termination criteria validity and
		///    sets eps to default_eps (if it is not set),
		///    max_iter to default_max_iters (if it is not set)
		/// 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCheckTermCriteria", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvTermCriteria cvCheckTermCriteria(CvTermCriteria criteria, double default_eps, int default_max_iters);

		/// <summary>
		///  dst(mask) = src1(mask) + src2(mask) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAdd", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAdd(IntPtr src1, IntPtr src2, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(mask) = src(mask) + value 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAddS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAddS(IntPtr src, CvScalar value, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(mask) = src1(mask) - src2(mask) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSub", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSub(IntPtr src1, IntPtr src2, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(mask) = value - src(mask) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSubRS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSubRS(IntPtr src, CvScalar value, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(idx) = src1(idx) * src2(idx) * scale
		///    (scaled element-wise multiplication of 2 arrays) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMul", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMul(IntPtr src1, IntPtr src2, IntPtr dst, double scale);

		/// <summary>
		///  element-wise division/inversion with scaling:
		///     dst(idx) = src1(idx) * scale / src2(idx)
		///     or dst(idx) = scale / src2(idx) if src1 == 0 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvDiv", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvDiv(IntPtr src1, IntPtr src2, IntPtr dst, double scale);

		/// <summary>
		///  dst = src1 * scale + src2 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvScaleAdd", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvScaleAdd(IntPtr src1, CvScalar scale, IntPtr src2, IntPtr dst);

		/// <summary>
		///  dst = src1 * alpha + src2 * beta + gamma 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAddWeighted", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAddWeighted(IntPtr src1, double alpha, IntPtr src2, double beta, double gamma, IntPtr dst);

		/// <summary>
		///  result = sum_i(src1(i) * src2(i)) (results for all channels are accumulated together) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvDotProduct", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvDotProduct(IntPtr src1, IntPtr src2);

		/// <summary>
		///  dst(idx) = src1(idx) & src2(idx) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAnd", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAnd(IntPtr src1, IntPtr src2, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(idx) = src(idx) & value 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAndS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAndS(IntPtr src, CvScalar value, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(idx) = src1(idx) | src2(idx) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvOr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvOr(IntPtr src1, IntPtr src2, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(idx) = src(idx) | value 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvOrS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvOrS(IntPtr src, CvScalar value, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(idx) = src1(idx) ^ src2(idx) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvXor", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvXor(IntPtr src1, IntPtr src2, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(idx) = src(idx) ^ value 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvXorS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvXorS(IntPtr src, CvScalar value, IntPtr dst, IntPtr mask);

		/// <summary>
		///  dst(idx) = ~src(idx) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvNot", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvNot(IntPtr src, IntPtr dst);

		/// <summary>
		///  dst(idx) = lower(idx) <= src(idx) < upper(idx) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInRange", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInRange(IntPtr src, IntPtr lower, IntPtr upper, IntPtr dst);

		/// <summary>
		///  dst(idx) = lower <= src(idx) < upper 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInRangeS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInRangeS(IntPtr src, CvScalar lower, CvScalar upper, IntPtr dst);

		/// <summary>
		///  dst(idx) = src1(idx) _cmp_op_ src2(idx) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCmp", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCmp(IntPtr src1, IntPtr src2, IntPtr dst, int cmp_op);

		/// <summary>
		///  dst(idx) = src1(idx) _cmp_op_ value 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCmpS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCmpS(IntPtr src, double value, IntPtr dst, int cmp_op);

		/// <summary>
		///  dst(idx) = min(src1(idx),src2(idx)) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMin", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMin(IntPtr src1, IntPtr src2, IntPtr dst);

		/// <summary>
		///  dst(idx) = max(src1(idx),src2(idx)) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMax", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMax(IntPtr src1, IntPtr src2, IntPtr dst);

		/// <summary>
		///  dst(idx) = min(src(idx),value) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMinS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMinS(IntPtr src, double value, IntPtr dst);

		/// <summary>
		///  dst(idx) = max(src(idx),value) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMaxS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMaxS(IntPtr src, double value, IntPtr dst);

		/// <summary>
		///  dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c)) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAbsDiff", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAbsDiff(IntPtr src1, IntPtr src2, IntPtr dst);

		/// <summary>
		///  dst(x,y,c) = abs(src(x,y,c) - value(c)) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAbsDiffS", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAbsDiffS(IntPtr src, IntPtr dst, CvScalar value);

		/// <summary>
		///  Does cartesian->polar coordinates conversion.
		///    Either of output components (magnitude or angle) is optional 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCartToPolar", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCartToPolar(IntPtr x, IntPtr y, IntPtr magnitude, IntPtr angle, int angle_in_degrees);

		/// <summary>
		///  Does polar->cartesian coordinates conversion.
		///    Either of output components (magnitude or angle) is optional.
		///    If magnitude is missing it is assumed to be all 1's 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvPolarToCart", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPolarToCart(IntPtr magnitude, IntPtr angle, IntPtr x, IntPtr y, int angle_in_degrees);

		/// <summary>
		///  Does powering: dst(idx) = src(idx)^power 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvPow", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPow(IntPtr src, IntPtr dst, double power);

		/// <summary>
		///  Does exponention: dst(idx) = exp(src(idx)).
		///    Overflow is not handled yet. Underflow is handled.
		///    Maximal relative error is ~7e-6 for single-precision input 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvExp", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvExp(IntPtr src, IntPtr dst);

		/// <summary>
		///  Calculates natural logarithms: dst(idx) = log(abs(src(idx))).
		///    Logarithm of 0 gives large negative number(~-700)
		///    Maximal relative error is ~3e-7 for single-precision output
		/// 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvLog", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvLog(IntPtr src, IntPtr dst);

		/// <summary>
		///  Fast arctangent calculation 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvFastArctan", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern float cvFastArctan(float y, float x);

		/// <summary>
		///  Fast cubic root calculation 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCbrt", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern float cvCbrt(float value);

		/// <summary>
		///  Checks array values for NaNs, Infs or simply for too large numbers
		///    (if CV_CHECK_RANGE is set). If CV_CHECK_QUIET is set,
		///    no runtime errors is raised (function returns zero value in case of "bad" values).
		///    Otherwise cvError is called 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCheckArr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvCheckArr(IntPtr arr, int flags, double min_val, double max_val);

		[DllImport(CxCoreDllName, EntryPoint = "cvRandArr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRandArr(IntPtr rng, IntPtr arr, int dist_type, CvScalar param1, CvScalar param2);

		[DllImport(CxCoreDllName, EntryPoint = "cvRandShuffle", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRandShuffle(IntPtr mat, IntPtr rng, double iter_factor);

		[DllImport(CxCoreDllName, EntryPoint = "cvSort", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSort(IntPtr src, IntPtr dst, IntPtr idxmat, int flags);

		/// <summary>
		///  Finds real roots of a cubic equation 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSolveCubic", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSolveCubic(IntPtr coeffs, IntPtr roots);

		/// <summary>
		///  Finds all real and complex roots of a polynomial equation 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSolvePoly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSolvePoly(IntPtr coeffs, IntPtr roots, int maxiter, int fig);

		/// <summary>
		///  Calculates cross product of two 3d vectors 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCrossProduct", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCrossProduct(IntPtr src1, IntPtr src2, IntPtr dst);

		/// <summary>
		///  Extended matrix transform:
		///    dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGEMM", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGEMM(IntPtr src1, IntPtr src2, double alpha, IntPtr src3, double beta, IntPtr dst, int tABC);

		/// <summary>
		///  Transforms each element of source array and stores
		///    resultant vectors in destination array 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvTransform", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvTransform(IntPtr src, IntPtr dst, IntPtr transmat, IntPtr shiftvec);

		/// <summary>
		///  Does perspective transform on every element of input array 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvPerspectiveTransform", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPerspectiveTransform(IntPtr src, IntPtr dst, IntPtr mat);

		/// <summary>
		///  Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMulTransposed", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMulTransposed(IntPtr src, IntPtr dst, int order, IntPtr delta, double scale);

		/// <summary>
		///  Tranposes matrix. Square matrices can be transposed in-place 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvTranspose", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvTranspose(IntPtr src, IntPtr dst);

		/// <summary>
		///  Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCompleteSymm", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCompleteSymm(IntPtr matrix, int LtoR);

		/// <summary>
		///  Mirror array data around horizontal (flip=0),
		///    vertical (flip=1) or both(flip=-1) axises:
		///    cvFlip(src) flips images vertically and sequences horizontally (inplace) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvFlip", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFlip(IntPtr src, IntPtr dst, int flip_mode);

		/// <summary>
		///  Performs Singular Value Decomposition of a matrix 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSVD", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSVD(IntPtr A, IntPtr W, IntPtr U, IntPtr V, int flags);

		/// <summary>
		///  Performs Singular Value Back Substitution (solves A*X = B):
		///    flags must be the same as in cvSVD 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSVBkSb", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSVBkSb(IntPtr W, IntPtr U, IntPtr V, IntPtr B, IntPtr X, int flags);

		/// <summary>
		///  Inverts matrix 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInvert", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvInvert(IntPtr src, IntPtr dst, int method);

		/// <summary>
		///  Solves linear system (src1)*(dst) = (src2)
		///    (returns 0 if src1 is a singular and CV_LU method is used) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSolve", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSolve(IntPtr src1, IntPtr src2, IntPtr dst, int method);

		/// <summary>
		///  Calculates determinant of input matrix 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvDet", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvDet(IntPtr mat);

		/// <summary>
		///  Calculates trace of the matrix (sum of elements on the main diagonal) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvTrace", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvTrace(IntPtr mat);

		/// <summary>
		///  Finds eigen values and vectors of a symmetric matrix 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvEigenVV", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvEigenVV(IntPtr mat, IntPtr evects, IntPtr evals, double eps);

		/// <summary>
		///  Makes an identity matrix (mat_ij = i == j) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetIdentity", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetIdentity(IntPtr mat, CvScalar value);

		/// <summary>
		///  Fills matrix with given range of numbers 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRange", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvRange(IntPtr mat, double start, double end);

		/// <summary>
		///  all the input vectors are stored in a single matrix, as its columns 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCalcCovarMatrix", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcCovarMatrix(IntPtr vects, int count, IntPtr cov_mat, IntPtr avg, int flags);

		[DllImport(CxCoreDllName, EntryPoint = "cvCalcPCA", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCalcPCA(IntPtr data, IntPtr mean, IntPtr eigenvals, IntPtr eigenvects, int flags);

		[DllImport(CxCoreDllName, EntryPoint = "cvProjectPCA", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvProjectPCA(IntPtr data, IntPtr mean, IntPtr eigenvects, IntPtr result);

		[DllImport(CxCoreDllName, EntryPoint = "cvBackProjectPCA", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvBackProjectPCA(IntPtr proj, IntPtr mean, IntPtr eigenvects, IntPtr result);

		/// <summary>
		///  Calculates Mahalanobis(weighted) distance 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMahalanobis", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvMahalanobis(IntPtr vec1, IntPtr vec2, IntPtr mat);

		/// <summary>
		///  Finds sum of array elements 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSum", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvSum(IntPtr arr);

		/// <summary>
		///  Calculates number of non-zero pixels 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCountNonZero", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvCountNonZero(IntPtr arr);

		/// <summary>
		///  Calculates mean value of array elements 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAvg", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvAvg(IntPtr arr, IntPtr mask);

		/// <summary>
		///  Calculates mean and standard deviation of pixel values 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAvgSdv", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvAvgSdv(IntPtr arr, IntPtr mean, IntPtr std_dev, IntPtr mask);

		/// <summary>
		///  Finds global minimum, maximum and their positions 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMinMaxLoc", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMinMaxLoc(IntPtr arr, IntPtr min_val, IntPtr max_val, IntPtr min_loc, IntPtr max_loc, IntPtr mask);

		/// <summary>
		///  Finds norm, difference norm or relative difference norm for an array (or two arrays) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvNorm", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvNorm(IntPtr arr1, IntPtr arr2, int norm_type, IntPtr mask);

		[DllImport(CxCoreDllName, EntryPoint = "cvNormalize", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvNormalize(IntPtr src, IntPtr dst, double a, double b, int norm_type, IntPtr mask);

		[DllImport(CxCoreDllName, EntryPoint = "cvReduce", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReduce(IntPtr src, IntPtr dst, int dim, int op);

		/// <summary>
		///  Discrete Fourier Transform:
		///     complex->complex,
		///     real->ccs (forward),
		///     ccs->real (inverse) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvDFT", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvDFT(IntPtr src, IntPtr dst, int flags, int nonzero_rows);

		/// <summary>
		///  Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y)) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMulSpectrums", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvMulSpectrums(IntPtr src1, IntPtr src2, IntPtr dst, int flags);

		/// <summary>
		///  Finds optimal DFT vector size >= size0 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetOptimalDFTSize", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetOptimalDFTSize(int size0);

		/// <summary>
		///  Discrete Cosine Transform 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvDCT", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvDCT(IntPtr src, IntPtr dst, int flags);

		/// <summary>
		///  Calculates length of sequence slice (with support of negative indices). 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSliceLength", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSliceLength(CvSlice slice, IntPtr seq);

		/// <summary>
		///  Creates new memory storage.
		///    block_size == 0 means that default,
		///    somewhat optimal size, is used (currently, it is 64K) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateMemStorage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateMemStorage(int block_size);

		/// <summary>
		///  Creates a memory storage that will borrow memory blocks from parent storage 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateChildMemStorage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateChildMemStorage(IntPtr parent);

		/// <summary>
		///  Releases memory storage. All the children of a parent must be released before
		///    the parent. A child storage returns all the blocks to parent when it is released 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseMemStorage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseMemStorage(IntPtr storage);

		/// <summary>
		///  Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos)
		///    to reuse memory allocated for the storage - cvClearSeq,cvClearSet ...
		///    do not free any memory.
		///    A child storage returns all the blocks to the parent when it is cleared 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvClearMemStorage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvClearMemStorage(IntPtr storage);

		/// <summary>
		///  Remember a storage "free memory" position 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSaveMemStoragePos", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSaveMemStoragePos(IntPtr storage, IntPtr pos);

		/// <summary>
		///  Restore a storage "free memory" position 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRestoreMemStoragePos", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRestoreMemStoragePos(IntPtr storage, IntPtr pos);

		/// <summary>
		///  Allocates continuous buffer of the specified size in the storage 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMemStorageAlloc", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvMemStorageAlloc(IntPtr storage, int size);

		/// <summary>
		///  Creates new empty sequence that will reside in the specified storage 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateSeq", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateSeq(int seq_flags, int header_size, int elem_size, IntPtr storage);

		/// <summary>
		///  Changes default size (granularity) of sequence blocks.
		///    The default size is ~1Kbyte 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetSeqBlockSize", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetSeqBlockSize(IntPtr seq, int delta_elems);

		/// <summary>
		///  Adds new element to the end of sequence. Returns pointer to the element 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqPush", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvSeqPush(IntPtr seq, IntPtr element);

		/// <summary>
		///  Adds new element to the beginning of sequence. Returns pointer to it 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqPushFront", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvSeqPushFront(IntPtr seq, IntPtr element);

		/// <summary>
		///  Removes the last element from sequence and optionally saves it 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqPop", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqPop(IntPtr seq, IntPtr element);

		/// <summary>
		///  Removes the first element from sequence and optioanally saves it 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqPopFront", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqPopFront(IntPtr seq, IntPtr element);

		/// <summary>
		///  Adds several new elements to the end of sequence 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqPushMulti", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqPushMulti(IntPtr seq, IntPtr elements, int count, int in_front);

		/// <summary>
		///  Removes several elements from the end of sequence and optionally saves them 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqPopMulti", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqPopMulti(IntPtr seq, IntPtr elements, int count, int in_front);

		/// <summary>
		///  Inserts a new element in the middle of sequence.
		///    cvSeqInsert(seq,0,elem) == cvSeqPushFront(seq,elem) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqInsert", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvSeqInsert(IntPtr seq, int before_index, IntPtr element);

		/// <summary>
		///  Removes specified sequence element 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqRemove", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqRemove(IntPtr seq, int index);

		/// <summary>
		///  Removes all the elements from the sequence. The freed memory
		///    can be reused later only by the same sequence unless cvClearMemStorage
		///    or cvRestoreMemStoragePos is called 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvClearSeq", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvClearSeq(IntPtr seq);

		/// <summary>
		///  Retrieves pointer to specified sequence element.
		///    Negative indices are supported and mean counting from the end
		///    (e.g -1 means the last sequence element) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetSeqElem", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetSeqElem(IntPtr seq, int index);

		/// <summary>
		///  Calculates index of the specified sequence element.
		///    Returns -1 if element does not belong to the sequence 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqElemIdx", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSeqElemIdx(IntPtr seq, IntPtr element, IntPtr block);

		/// <summary>
		///  Initializes sequence writer. The new elements will be added to the end of sequence 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvStartAppendToSeq", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStartAppendToSeq(IntPtr seq, IntPtr writer);

		/// <summary>
		///  Combination of cvCreateSeq and cvStartAppendToSeq 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvStartWriteSeq", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStartWriteSeq(int seq_flags, int header_size, int elem_size, IntPtr storage, IntPtr writer);

		/// <summary>
		///  Closes sequence writer, updates sequence header and returns pointer
		///    to the resultant sequence
		///    (which may be useful if the sequence was created using cvStartWriteSeq))
		/// 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvEndWriteSeq", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvEndWriteSeq(IntPtr writer);

		/// <summary>
		///  Updates sequence header. May be useful to get access to some of previously
		///    written elements via cvGetSeqElem or sequence reader 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvFlushSeqWriter", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFlushSeqWriter(IntPtr writer);

		/// <summary>
		///  Initializes sequence reader.
		///    The sequence can be read in forward or backward direction 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvStartReadSeq", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStartReadSeq(IntPtr seq, IntPtr reader, int reverse);

		/// <summary>
		///  Returns current sequence reader position (currently observed sequence element) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetSeqReaderPos", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetSeqReaderPos(IntPtr reader);

		/// <summary>
		///  Changes sequence reader position. It may seek to an absolute or
		///    to relative to the current position 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetSeqReaderPos", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetSeqReaderPos(IntPtr reader, int index, int is_relative);

		/// <summary>
		///  Copies sequence content to a continuous piece of memory 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCvtSeqToArray", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCvtSeqToArray(IntPtr seq, IntPtr elements, CvSlice slice);

		/// <summary>
		///  Creates sequence header for array.
		///    After that all the operations on sequences that do not alter the content
		///    can be applied to the resultant sequence 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvMakeSeqHeaderForArray", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvMakeSeqHeaderForArray(int seq_type, int header_size, int elem_size, IntPtr elements, int total, IntPtr seq, IntPtr block);

		/// <summary>
		///  Extracts sequence slice (with or without copying sequence elements) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqSlice", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvSeqSlice(IntPtr seq, CvSlice slice, IntPtr storage, int copy_data);

		/// <summary>
		///  Removes sequence slice 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqRemoveSlice", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqRemoveSlice(IntPtr seq, CvSlice slice);

		/// <summary>
		///  Inserts a sequence or array into another sequence 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqInsertSlice", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqInsertSlice(IntPtr seq, int before_index, IntPtr from_arr);

		/// <summary>
		///  Sorts sequence in-place given element comparison function 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqSort", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqSort(IntPtr seq, IntPtr func, IntPtr userdata);

		/// <summary>
		///  Finds element in a [sorted] sequence 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqSearch", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvSeqSearch(IntPtr seq, IntPtr elem, IntPtr func, int is_sorted, IntPtr elem_idx, IntPtr userdata);

		/// <summary>
		///  Reverses order of sequence elements in-place 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqInvert", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSeqInvert(IntPtr seq);

		/// <summary>
		///  Splits sequence into one or more equivalence classes using the specified criteria 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSeqPartition", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSeqPartition(IntPtr seq, IntPtr storage, IntPtr labels, IntPtr is_equal, IntPtr userdata);

		/// <summary>
		/// *********** Internal sequence functions ***********
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvChangeSeqBlock", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvChangeSeqBlock(IntPtr reader, int direction);

		[DllImport(CxCoreDllName, EntryPoint = "cvCreateSeqBlock", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCreateSeqBlock(IntPtr writer);

		/// <summary>
		///  Creates a new set 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateSet", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateSet(int set_flags, int header_size, int elem_size, IntPtr storage);

		/// <summary>
		///  Adds new element to the set and returns pointer to it 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetAdd", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSetAdd(IntPtr set_header, IntPtr elem, IntPtr inserted_elem);

		/// <summary>
		///  Removes element from the set by its index  
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetRemove", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetRemove(IntPtr set_header, int index);

		/// <summary>
		///  Removes all the elements from the set 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvClearSet", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvClearSet(IntPtr set_header);

		/// <summary>
		///  Creates new graph 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateGraph", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateGraph(int graph_flags, int header_size, int vtx_size, int edge_size, IntPtr storage);

		/// <summary>
		///  Adds new vertex to the graph 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGraphAddVtx", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGraphAddVtx(IntPtr graph, IntPtr vtx, IntPtr inserted_vtx);

		/// <summary>
		///  Removes vertex from the graph together with all incident edges 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGraphRemoveVtx", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGraphRemoveVtx(IntPtr graph, int index);

		[DllImport(CxCoreDllName, EntryPoint = "cvGraphRemoveVtxByPtr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGraphRemoveVtxByPtr(IntPtr graph, IntPtr vtx);

		/// <summary>
		///  Link two vertices specifed by indices or pointers if they
		///    are not connected or return pointer to already existing edge
		///    connecting the vertices.
		///    Functions return 1 if a new edge was created, 0 otherwise 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGraphAddEdge", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGraphAddEdge(IntPtr graph, int start_idx, int end_idx, IntPtr edge, IntPtr inserted_edge);

		[DllImport(CxCoreDllName, EntryPoint = "cvGraphAddEdgeByPtr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGraphAddEdgeByPtr(IntPtr graph, IntPtr start_vtx, IntPtr end_vtx, IntPtr edge, IntPtr inserted_edge);

		/// <summary>
		///  Remove edge connecting two vertices 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGraphRemoveEdge", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGraphRemoveEdge(IntPtr graph, int start_idx, int end_idx);

		[DllImport(CxCoreDllName, EntryPoint = "cvGraphRemoveEdgeByPtr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGraphRemoveEdgeByPtr(IntPtr graph, IntPtr start_vtx, IntPtr end_vtx);

		/// <summary>
		///  Find edge connecting two vertices 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvFindGraphEdge", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvFindGraphEdge(IntPtr graph, int start_idx, int end_idx);

		[DllImport(CxCoreDllName, EntryPoint = "cvFindGraphEdgeByPtr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvFindGraphEdgeByPtr(IntPtr graph, IntPtr start_vtx, IntPtr end_vtx);

		/// <summary>
		///  Remove all vertices and edges from the graph 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvClearGraph", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvClearGraph(IntPtr graph);

		/// <summary>
		///  Count number of edges incident to the vertex 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGraphVtxDegree", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGraphVtxDegree(IntPtr graph, int vtx_idx);

		[DllImport(CxCoreDllName, EntryPoint = "cvGraphVtxDegreeByPtr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGraphVtxDegreeByPtr(IntPtr graph, IntPtr vtx);

		/// <summary>
		///  Creates new graph scanner. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCreateGraphScanner", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCreateGraphScanner(IntPtr graph, IntPtr vtx, int mask);

		/// <summary>
		///  Releases graph scanner. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseGraphScanner", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseGraphScanner(IntPtr scanner);

		/// <summary>
		///  Get next graph element 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvNextGraphItem", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvNextGraphItem(IntPtr scanner);

		/// <summary>
		///  Creates a copy of graph 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCloneGraph", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvCloneGraph(IntPtr graph, IntPtr storage);

		/// <summary>
		///  Draws 4-connected, 8-connected or antialiased line segment connecting two points 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvLine", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvLine(IntPtr img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift);

		/// <summary>
		///  Draws a rectangle given two opposite corners of the rectangle (pt1 & pt2),
		///    if thickness<0 (e.g. thickness == CV_FILLED), the filled box is drawn 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRectangle", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRectangle(IntPtr img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift);

		/// <summary>
		///  Draws a circle with specified center and radius.
		///    Thickness works in the same way as with cvRectangle 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvCircle", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvCircle(IntPtr img, CvPoint center, int radius, CvScalar color, int thickness, int line_type, int shift);

		/// <summary>
		///  Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector,
		///    depending on <thickness>, <start_angle> and <end_angle> parameters. The resultant figure
		///    is rotated by <angle>. All the angles are in degrees 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvEllipse", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvEllipse(IntPtr img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, CvScalar color, int thickness, int line_type, int shift);

		/// <summary>
		///  Fills convex or monotonous polygon. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvFillConvexPoly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFillConvexPoly(IntPtr img, IntPtr pts, int npts, CvScalar color, int line_type, int shift);

		/// <summary>
		///  Fills an area bounded by one or more arbitrary polygons 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvFillPoly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvFillPoly(IntPtr img, IntPtr pts, IntPtr npts, int contours, CvScalar color, int line_type, int shift);

		/// <summary>
		///  Draws one or more polygonal curves 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvPolyLine", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPolyLine(IntPtr img, IntPtr pts, IntPtr npts, int contours, int is_closed, CvScalar color, int thickness, int line_type, int shift);

		/// <summary>
		///  Clips the line segment connecting *pt1 and *pt2
		///    by the rectangular window
		///    (0<=x<img_size.width, 0<=y<img_size.height). 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvClipLine", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvClipLine(CvSize img_size, IntPtr pt1, IntPtr pt2);

		/// <summary>
		///  Initializes line iterator. Initially, line_iterator->ptr will point
		///    to pt1 (or pt2, see left_to_right description) location in the image.
		///    Returns the number of pixels on the line between the ending points. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitLineIterator", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvInitLineIterator(IntPtr image, CvPoint pt1, CvPoint pt2, IntPtr line_iterator, int connectivity, int left_to_right);

		/// <summary>
		///  Initializes font structure used further in cvPutText 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitFont", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInitFont(IntPtr font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type);

		/// <summary>
		///  Renders text stroke with specified font and color at specified location.
		///    CvFont should be initialized with cvInitFont 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvPutText", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvPutText(IntPtr img, [MarshalAs(UnmanagedType.LPStr)] string text, CvPoint org, IntPtr font, CvScalar color);

		/// <summary>
		///  Calculates bounding box of text stroke (useful for alignment) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetTextSize", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGetTextSize([MarshalAs(UnmanagedType.LPStr)] string text_string, IntPtr font, IntPtr text_size, IntPtr baseline);

		/// <summary>
		///  Unpacks color value, if arrtype is CV_8UC?, <color> is treated as
		///    packed color value, otherwise the first channels (depending on arrtype)
		///    of destination scalar are set to the same value = <color> 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvColorToScalar", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern CvScalar cvColorToScalar(double packed_color, int arrtype);

		/// <summary>
		///  Returns the polygon points which make up the given ellipse.  The ellipse is define by
		///    the box of size 'axes' rotated 'angle' around the 'center'.  A partial sweep
		///    of the ellipse arc can be done by spcifying arc_start and arc_end to be something
		///    other than 0 and 360, respectively.  The input array 'pts' must be large enough to
		///    hold the result.  The total number of points stored into 'pts' is returned by this
		///    function. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvEllipse2Poly", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvEllipse2Poly(CvPoint center, CvSize axes, int angle, int arc_start, int arc_end, IntPtr pts, int delta);

		/// <summary>
		///  Draws contour outlines or filled interiors on the image 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvDrawContours", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvDrawContours(IntPtr img, IntPtr contour, CvScalar external_color, CvScalar hole_color, int max_level, int thickness, int line_type, CvPoint offset);

		/// <summary>
		///  Does look-up transformation. Elements of the source array
		///    (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvLUT", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvLUT(IntPtr src, IntPtr dst, IntPtr lut);

		/// <summary>
		/// ****************** Iteration through the sequence tree ****************
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInitTreeNodeIterator", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInitTreeNodeIterator(IntPtr tree_iterator, IntPtr first, int max_level);

		[DllImport(CxCoreDllName, EntryPoint = "cvNextTreeNode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvNextTreeNode(IntPtr tree_iterator);

		[DllImport(CxCoreDllName, EntryPoint = "cvPrevTreeNode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvPrevTreeNode(IntPtr tree_iterator);

		/// <summary>
		///  Inserts sequence into tree with specified "parent" sequence.
		///    If parent is equal to frame (e.g. the most external contour),
		///    then added contour will have null pointer to parent. 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvInsertNodeIntoTree", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvInsertNodeIntoTree(IntPtr node, IntPtr parent, IntPtr frame);

		/// <summary>
		///  Removes contour from tree (together with the contour children). 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRemoveNodeFromTree", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRemoveNodeFromTree(IntPtr node, IntPtr frame);

		/// <summary>
		///  Gathers pointers to all the sequences,
		///    accessible from the <first>, to the single sequence 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvTreeToNodeSeq", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvTreeToNodeSeq(IntPtr first, int header_size, IntPtr storage);

		/// <summary>
		///  The function implements the K-means algorithm for clustering an array of sample
		///    vectors in a specified number of classes 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvKMeans2", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvKMeans2(IntPtr samples, int cluster_count, IntPtr labels, CvTermCriteria termcrit);

		/// <summary>
		///  Add the function pointers table with associated information to the IPP primitives list 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRegisterModule", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvRegisterModule(IntPtr module_info);

		/// <summary>
		///  Loads optimized functions from IPP, MKL etc. or switches back to pure C code 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvUseOptimized", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvUseOptimized(int on_off);

		/// <summary>
		///  Retrieves information about the registered modules and loaded optimized plugins 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetModuleInfo", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvGetModuleInfo([MarshalAs(UnmanagedType.LPStr)] string module_name, IntPtr version, IntPtr loaded_addon_plugins);

		/// <summary>
		///  Get current OpenCV error status 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetErrStatus", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetErrStatus();

		/// <summary>
		///  Sets error status silently 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetErrStatus", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetErrStatus(int status);

		/// <summary>
		///  Retrives current error processing mode 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetErrMode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetErrMode();

		/// <summary>
		///  Sets error processing mode, returns previously used mode 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetErrMode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvSetErrMode(int mode);

		/// <summary>
		///  Sets error status and performs some additonal actions (displaying message box,
		///    writing message to stderr, terminating application etc.)
		///    depending on the current error mode 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvError", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvError(int status, [MarshalAs(UnmanagedType.LPStr)] string func_name, [MarshalAs(UnmanagedType.LPStr)] string err_msg, [MarshalAs(UnmanagedType.LPStr)] string file_name, int line);

		/// <summary>
		///  Retrieves textual description of the error given its code 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvErrorStr", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		[return:MarshalAs(UnmanagedType.LPStr)]
		public static extern string cvErrorStr(int status);

		/// <summary>
		///  Retrieves detailed information about the last error occured 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetErrInfo", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetErrInfo(IntPtr errcode_desc, IntPtr description, IntPtr filename, IntPtr line);

		/// <summary>
		///  Maps IPP error codes to the counterparts from OpenCV 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvErrorFromIppStatus", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvErrorFromIppStatus(int ipp_status);

		/// <summary>
		///  Assigns a new error-handling function 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRedirectError", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvRedirectError(IntPtr error_handler, IntPtr userdata, IntPtr prev_userdata);

		/// <summary>
		/// 
		///     Output to:
		///         cvNulDevReport - nothing
		///         cvStdErrReport - console(fprintf(stderr,...))
		///         cvGuiBoxReport - MessageBox(WIN32)
		/// 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvNulDevReport", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvNulDevReport(int status, [MarshalAs(UnmanagedType.LPStr)] string func_name, [MarshalAs(UnmanagedType.LPStr)] string err_msg, [MarshalAs(UnmanagedType.LPStr)] string file_name, int line, IntPtr userdata);

		[DllImport(CxCoreDllName, EntryPoint = "cvStdErrReport", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvStdErrReport(int status, [MarshalAs(UnmanagedType.LPStr)] string func_name, [MarshalAs(UnmanagedType.LPStr)] string err_msg, [MarshalAs(UnmanagedType.LPStr)] string file_name, int line, IntPtr userdata);

		[DllImport(CxCoreDllName, EntryPoint = "cvGuiBoxReport", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGuiBoxReport(int status, [MarshalAs(UnmanagedType.LPStr)] string func_name, [MarshalAs(UnmanagedType.LPStr)] string err_msg, [MarshalAs(UnmanagedType.LPStr)] string file_name, int line, IntPtr userdata);

		/// <summary>
		///  Set user-defined memory managment functions (substitutors for malloc and free) that
		///    will be called by cvAlloc, cvFree and higher-level functions (e.g. cvCreateImage) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetMemoryManager", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetMemoryManager(IntPtr alloc_func, IntPtr free_func, IntPtr userdata);

		/// <summary>
		///  Makes OpenCV use IPL functions for IplImage allocation/deallocation 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSetIPLAllocators", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetIPLAllocators(IntPtr create_header, IntPtr allocate_data, IntPtr deallocate, IntPtr create_roi, IntPtr clone_image);

		/// <summary>
		///  opens existing or creates new file storage 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvOpenFileStorage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvOpenFileStorage([MarshalAs(UnmanagedType.LPStr)] string filename, IntPtr memstorage, int flags);

		/// <summary>
		///  closes file storage and deallocates buffers 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReleaseFileStorage", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReleaseFileStorage(IntPtr fs);

		/// <summary>
		///  returns attribute value or 0 (NULL) if there is no such attribute 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvAttrValue", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		[return:MarshalAs(UnmanagedType.LPStr)]
		public static extern string cvAttrValue(IntPtr attr, [MarshalAs(UnmanagedType.LPStr)] string attr_name);

		/// <summary>
		///  starts writing compound structure (map or sequence) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvStartWriteStruct", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStartWriteStruct(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string name, int struct_flags, [MarshalAs(UnmanagedType.LPStr)] string type_name, CvAttrList attributes);

		/// <summary>
		///  finishes writing compound structure 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvEndWriteStruct", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvEndWriteStruct(IntPtr fs);

		/// <summary>
		///  writes an integer 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvWriteInt", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWriteInt(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string name, int value);

		/// <summary>
		///  writes a floating-point number 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvWriteReal", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWriteReal(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string name, double value);

		/// <summary>
		///  writes a string 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvWriteString", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWriteString(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string str, int quote);

		/// <summary>
		///  writes a comment 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvWriteComment", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWriteComment(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string comment, int eol_comment);

		/// <summary>
		///  writes instance of a standard type (matrix, image, sequence, graph etc.)
		///    or user-defined type 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvWrite", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWrite(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string name, IntPtr ptr, CvAttrList attributes);

		/// <summary>
		///  starts the next stream 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvStartNextStream", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStartNextStream(IntPtr fs);

		/// <summary>
		///  helper function: writes multiple integer or floating-point numbers 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvWriteRawData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWriteRawData(IntPtr fs, IntPtr src, int len, [MarshalAs(UnmanagedType.LPStr)] string dt);

		/// <summary>
		///  returns the hash entry corresponding to the specified literal key string or 0
		///    if there is no such a key in the storage 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetHashedKey", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetHashedKey(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string name, int len, int create_missing);

		/// <summary>
		///  returns file node with the specified key within the specified map
		///    (collection of named nodes) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetRootFileNode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetRootFileNode(IntPtr fs, int stream_index);

		/// <summary>
		///  returns file node with the specified key within the specified map
		///    (collection of named nodes) 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetFileNode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetFileNode(IntPtr fs, IntPtr map, IntPtr key, int create_missing);

		/// <summary>
		///  this is a slower version of cvGetFileNode that takes the key as a literal string 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetFileNodeByName", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvGetFileNodeByName(IntPtr fs, IntPtr map, [MarshalAs(UnmanagedType.LPStr)] string name);

		/// <summary>
		///  decodes standard or user-defined object and returns it 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRead", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvRead(IntPtr fs, IntPtr node, IntPtr attributes);

		/// <summary>
		///  starts reading data from sequence or scalar numeric node 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvStartReadRawData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvStartReadRawData(IntPtr fs, IntPtr src, IntPtr reader);

		/// <summary>
		///  reads multiple numbers and stores them to array 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReadRawDataSlice", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReadRawDataSlice(IntPtr fs, IntPtr reader, int count, IntPtr dst, [MarshalAs(UnmanagedType.LPStr)] string dt);

		/// <summary>
		///  combination of two previous functions for easier reading of whole sequences 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvReadRawData", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvReadRawData(IntPtr fs, IntPtr src, IntPtr dst, [MarshalAs(UnmanagedType.LPStr)] string dt);

		/// <summary>
		///  writes a copy of file node to file storage 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvWriteFileNode", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvWriteFileNode(IntPtr fs, [MarshalAs(UnmanagedType.LPStr)] string new_node_name, IntPtr node, int embed);

		/// <summary>
		///  returns name of file node 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetFileNodeName", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		[return:MarshalAs(UnmanagedType.LPStr)]
		public static extern string cvGetFileNodeName(IntPtr node);

		/// <summary>
		/// ********************************** Adding own types **********************************
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRegisterType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRegisterType(IntPtr info);

		[DllImport(CxCoreDllName, EntryPoint = "cvUnregisterType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvUnregisterType([MarshalAs(UnmanagedType.LPStr)] string type_name);

		[DllImport(CxCoreDllName, EntryPoint = "cvFirstType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvFirstType();

		[DllImport(CxCoreDllName, EntryPoint = "cvFindType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvFindType([MarshalAs(UnmanagedType.LPStr)] string type_name);

		[DllImport(CxCoreDllName, EntryPoint = "cvTypeOf", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvTypeOf(IntPtr struct_ptr);

		/// <summary>
		///  universal functions 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvRelease", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvRelease(IntPtr struct_ptr);

		[DllImport(CxCoreDllName, EntryPoint = "cvClone", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvClone(IntPtr struct_ptr);

		/// <summary>
		///  simple API for reading/writing data 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvSave", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSave([MarshalAs(UnmanagedType.LPStr)] string filename, IntPtr struct_ptr, [MarshalAs(UnmanagedType.LPStr)] string name, [MarshalAs(UnmanagedType.LPStr)] string comment, CvAttrList attributes);

		[DllImport(CxCoreDllName, EntryPoint = "cvLoad", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern IntPtr cvLoad([MarshalAs(UnmanagedType.LPStr)] string filename, IntPtr memstorage, [MarshalAs(UnmanagedType.LPStr)] string name, IntPtr real_name);

		/// <summary>
		///  helper functions for RNG initialization and accurate time measurement:
		///    uses internal clock counter on x86 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetTickCount", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern Int64 cvGetTickCount();

		[DllImport(CxCoreDllName, EntryPoint = "cvGetTickFrequency", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern double cvGetTickFrequency();

		/// <summary>
		///  retrieve/set the number of threads used in OpenMP implementations 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetNumThreads", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetNumThreads();

		[DllImport(CxCoreDllName, EntryPoint = "cvSetNumThreads", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern void cvSetNumThreads(int threads);

		/// <summary>
		///  get index of the thread being executed 
		/// </summary>
		[DllImport(CxCoreDllName, EntryPoint = "cvGetThreadNum", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		public static extern int cvGetThreadNum();
	}
}
